{
  "ver": "1.0.9",
  "uuid": "9888fc0e-843b-4755-86d9-84cd91481b3b",
  "compiledShaders": [
    {
      "vert": "#define _IS_VERT_SHADER 1\n\n  uniform mat4 cc_matViewProj;\n  uniform mat4 cc_matWorld;\n\n  attribute vec3 a_position;\n  attribute mediump vec2 a_uv0;\n  varying mediump vec2 v_uv0;\n\n  void main () {\n    mat4 mvp = cc_matViewProj * cc_matWorld;\n    v_uv0 = a_uv0;\n    gl_Position = mvp * vec4(a_position, 1);\n  }\n\n",
      "frag": "#define _IS_FRAG_SHADER 1\n\n  uniform sampler2D origin;\n  uniform sampler2D blurred;\n\n  uniform vec3 resolution; \n  uniform float vignette;\n  uniform float u_time;\n\n  varying mediump vec2 v_uv0;\n  \n  \n\nvec3 gammaToLinearSpaceRGB(in vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 linearToGammaSpaceRGB(in vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\n\nvec4 gammaToLinearSpaceRGBA(in vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\n\nvec4 linearToGammaSpaceRGBA(in vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\n\nvec4 linearToLinear (in vec4 value) {\n  return value;\n}\n\n#if INPUT_IS_GAMMA\n  #define TEXEL_TO_LINEAR gammaToLinearSpaceRGBA\n#else\n  #define TEXEL_TO_LINEAR linearToLinear\n#endif\n\n#if OUTPUT_TO_GAMMA\n  #define LINEAR_TO_OUTPUT_TEXEL linearToGammaSpaceRGBA\n#else\n  #define LINEAR_TO_OUTPUT_TEXEL linearToLinear\n#endif\n\n  \n  \n  float random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n  }\n  vec2 random2 (vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n  }\n  float noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(random2(i + vec2(0)), f - vec2(0)),\n      dot(random2(i + vec2(1, 0)), f - vec2(1, 0)), u.x),\n      mix(dot(random2(i + vec2(0, 1)), f - vec2(0, 1)),\n      dot(random2(i + vec2(1, 1)), f - vec2(1, 1)), u.x), u.y);\n  }\n\n  float fbm (vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 5; i++) {\n      total += noise(n) * amplitude;\n      n += n;\n      amplitude *= 0.5;\n    }\n    return total;\n  }\n\n  void main () {\n    vec2 uv = vec2(v_uv0.x, 1.0 - v_uv0.y);\n    vec4 o = texture2D(origin, uv);\n    vec4 b = texture2D(blurred, uv);\n\n    vec2 st = uv - 0.5;\n    st.x *= resolution.z;\n\n    float shaft = 0.0, mask = 0.0;\n    if (dot(b.rgb, b.rgb) < 0.7) {\n      mask  = mix(mask,  1.0, fbm(vec2(st.x * 2.0  + u_time / 40.0 + 10.0  , st.y / 4.0)) * smoothstep(-0.5, 0.5, st.y));\n      mask  = mix(mask,  1.0, fbm(vec2(st.x * 2.0  - u_time / 40.0 + 1000.0, st.y / 4.0)) * smoothstep(-0.5, 0.5, st.y));\n      shaft = mix(mask,  1.0, fbm(vec2(st.x * 10.0 + u_time / 15.0,          st.y / 4.0)) * mask);\n      shaft = mix(shaft, 1.0, fbm(vec2(st.x * 10.0 - u_time / 15.0 + 1000.0, st.y / 4.0)) * mask);\n    }\n\n    float rf = sqrt(dot(st * 2.0, st * 2.0)) * vignette;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n\n    vec3 c = o.rgb + b.rgb + max(0.0, shaft);\n    c /= c + vec3(1.0);\n    gl_FragColor = LINEAR_TO_OUTPUT_TEXEL(vec4(c * e, 1));\n  }\n\n"
    }
  ],
  "subMetas": {}
}